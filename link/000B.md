## 基本数据链路层协议
* 阅读难度:低

---

* 之前我们谈了数据链路层一些基本内容，那么现在我们就来谈一下数据链路层的基本协议，不过在谈协议之前，我们先来了解一些基本知识.

### 基础知识
* to_physical_layer：向物理层发送一帧
* from__physical_layer:在物理层接收一帧
* wait_for_event(&event)：过程调用，标示数据链路层正在等待事情的发生，只有当
确实发生了什么事情的时候(比如，到达一个帧的时候)，过程才会返回
* boolean :一个布尔类型的值
* seq__nr:一个小整数，用来对帧编号，以便区分不同的帧
* packet：同一台机器上网络层和数据链路层之间，或者是不同机器上的网络对等实体
* 一个帧由4个字段组成:kind,seq,ack,和info.
  * kind:指出帧里面是否有数据
  * seq和ack分别做用作序号和确认
  * 控制帧的info包含一个数据包,控制帧的info没有用
* start_timer 和stop_timer 分别打开和关闭计时器
* start_ack_timer 和stop__ack_timer控制一个辅助计数器
* enable_network__layer和disable_network_layer用在较复杂的协议，在这样的协议，我们不再假设网络层总是有数据要发送。当数据链路层启动网络层后，它就允许网络层在有数据包要发送是中断自己。

---

* 在介绍完基本信息以后，我们就来谈一下协议了。我们今天先来谈一下比较简单的协议。

### 有错信道的单工停-等式协议
我们先假设在这个协议，数据只能单向传输，发送方以高于接收方能处理到达帧的速度发送帧，导致接收方被淹没，然后信道可能会出错。帧可能会被破坏(帧的校验和就发挥作用了)，也可能完全丢失

这个就是我们面对的情况了.

首先，我们来处理，发送量太大淹没接收方的情况。

现在我们可以用比较合理的解决方法，先举一下生活中的例子，假如你去别人家做客，主人太热情了，煮了一桌子的菜，然后还拼命的往你的碗里夹菜，眼看着你的碗就要满了，菜都快要满出来了，你会怎么办。如果是我呢，肯定会跟主人说不要夹了，要掉出来了。

对，就是要给给你信息的那个人说，你"吃不过来"。协议也是这样，让接收方给发送方提供反馈信息。接收方将数据包传给网络层后给发送方发回去一个哑帧，实际上这一帧的作用是给发送方一个许可，允许它发送下一帧。发送方在发出一帧之后，根据协议要求，它必须等待一段时间知道确认帧的到达。

我们来考虑一下下面的场景

1. 机器1的网络层将数据包1交给它的数据链路层。机器2正确接收到该数据包，并且将它传递给机器2的网络层。机器2给机器1发回一个确认帧
2. 确认帧完全丢失了，它永远也没用可能到达机器1
3. 机器1的数据链路层最终超时。由于它没有收到确认，所以它(不正确地)认为自己发的数据帧丢失了或者被损坏，于是他再次发送一个包含数据包1的帧
4. 这个重复的帧也完好无损地到达机器2的数据链路层，并且不知不觉中被传到了网络层。(结果，这个帧重复了，出错了)

----

我们现在来讨论一下传输出错的处理方法。

对于接收方来说，它需要一种办法能够区分达到的帧是第一次发来的新帧，还是被重传的老帧。为了做到这一点，很显然的一个做法是让发送方在它发送的每个帧头部放上一个序号。然后，接收方可以检查它所接收到的每个帧的序号，由此判断这是个新帧还是重复帧

那么问题就来了，我们的序号要设置成几位的呢？答案： 1位

我们就来说一下为什么是1位。

在发送方，触发发送m+1位的事件是m号帧的确认帧已经按时返回了，也就是说第m-1位的帧也被接收方正确接收了，而且它的确认帧也已经被发送方接收了。所以我们要考虑的是一帧和它前一帧或者下一帧的关系，所以1位序号(0 1)就能解决问题.

在任何一个时刻，接收方期望下一个特定的序号。当包含正确序号的帧到来时，它被接收下来并且传到网络层。然后，接收方期待的下一个序号进行异或操作，任何一个到达的帧，若果包含了错误序号，都将作为重复帧而遭到拒绝。不过，最后一个有效的确认帧要被重复，以便发送方最终发现已经被接收的那个帧

如果一个协议中，发送方在前移到下一个数据之前必须等待一个肯定确认，这样的协议称为自动重复请求(ARQ,Automatic Repeat Request)或带有重传的肯定确认(PAR，Positive Acknowledgement with Retransmission),这种协议也只在一个方向上传输数据

我们就来看一下这个协议的实现咯(当然是C语言的啦)

![PAR](https://github.com/SeaHub/BlogOfComputerNetwork/blob/master/res/par.png)

### 总结
我们来聊了一下比较简单的单向协议，但是在大多数实际环境中，往往是需要两个方向上同时传输数据，所以，更多更复杂，更贴合实际的协议，我们下个星期再讨论啦。
