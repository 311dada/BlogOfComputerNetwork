# 浅谈网络层03之路由算法
### 前言
之前我们就有提到过自适应路由算法（即动态路由算法），那么现在我们就来聊一下相关的动态路由算法

### 距离矢量算法
矢量距离算法的工作原理是：每个路由器维护一张表(即一个矢量)，表中列出
了当前已知的到每个目标的最佳距离，以及所使用的链路。这些表通过邻居之间相互交换信息而
不断被更新，每个路由器都了解每个到达每个目的地的 最佳链路

在距离矢量路由算法中，每个路由器维护一张路由表，它以网络每个路由器为索引
，并且每个路由器对应一个表项。该表项包含两个部分：到达该目标路由器的首选出境
线路，以及到达该目标的距离估计值，距离的度量不是绝对的，正如我们前面提到的那样
，度量可以是很多中因素。
假定路由器知道他到每一个邻居的距离。如果所用的度量是跳数，那么距离就是一跳(因为是邻居嘛)。如果
度量值为传播延迟，则路由器很容易测量出链路的传播延迟。他只要直接发送一个特殊的echo数据(回显数据)，邻居收到后盖上
时间戳，尽可能快地发回来就可以知道延迟了。
现在就让我们来看一下
![](https://github.com/SeaHub/BlogOfComputerNetwork/blob/master/res/dvr.png)
如图，左图显示了一个网络，右图显示的是A I H K 四个路由器到其他路由器的延迟时间，例如I声称到A的延迟是24ms ，到B是36ms的延迟..,然后知道J已经测量
和估计了它到零件A I H K的延迟分别是8 10 12 6(看最右边更新的表项).现在要找出一条到G的最短路径，已知J到A延迟是8ms，A声称它到G延迟是18，所以J经过A到G的延迟是26
，同理可得JIG=41(31+10) JHG=18(6+12) JKG=37(31+6).所以，很容易就可以看出，最佳的路径是JHG
##### 问题
整个网络最佳路径的寻求过程称为收敛。距离矢量路由算法作为一项简单技术很有用，因为路由器可以在所有的路径中选择出一条
最短路径。但实际上它存在着一个非常严重的问题，它对于正确的信息反应很迅速，但是对于不正确的信息就反应很缓慢，似乎很抽象，现在我们就来
聊一聊是什么回事。
![](https://github.com/SeaHub/BlogOfComputerNetwork/blob/master/res/cti.png)
如图，路由器B C D E 到A 的距离分别是1 2 3 4。突然间A B之间的链路断开连接了，所以在第一次信息交换是，B没有听到来自A的任何信息，幸运的是，C说“不用担心，我有一条通向A的长度为2的路径”。
B并不怀疑,然后B就认为他可以通过C到达A，路径长度为3(似乎出现了问题),在第一次交换以后，D和E并不更新它们的A表项，第二次交换的时候，C注意到了，他有两个邻居声称了一条延迟为3的
到达A的路径，它随机挑选一条，并把自己到A的距离更新为4，这个时候，我们应该发现出现了问题了，逐渐地，所有的路由器都会趋向无穷大，但是所需的交换的次数依赖于代表无穷大的
数值。所以，明智的做法是把无穷大设置为最长的路径加一
### 链路状态路由
因为矢量路由算法存在的收敛问题，所以需要有更好的算法来取代它，它就是链路状态路由算法
链路状态算法的设计思想很简单，可以用五个部分来描述，这五个部分是缺一不可的；分别是
* 发现它的邻居节点，并了解其网络地址
* 设置到每个邻居节点的距离或者成本度量值
* 构造一个包含所有刚获得的链路信息包
* 将这个发送给所有其他的路由器，并接收来自所有其它路由器的信息包
* 计算出到每个其他路由器的最短路径
##### 发现邻居
它只需要在每一条的点到点线路上发送一个特殊的HELLO数据包。线路的另一端的路由器应该返回一个应答说明自己是谁，说明自己声明的名字(或者称为标示)
必须是唯一的
##### 设置链路成本
为了寻找最短路径，链路状态路由算法需要每条链路以距离或成本度量，举例以成本度量,一种选择就是成本与链路带宽成反比，例如1Gbps的以太网成本是1
，而100mbps的成本可能是10.这样就可以使得高容量额的路径成为路由更好的选择
##### 构造链路延迟状态包
该数据包的内容首先是发送方的标示符(上面提到的名字)，接着是一个序号和年龄，还有一个邻居列表，对于每个邻居，还有到这个邻居延迟，接下来我们会详细分析一下数据包的
![](https://github.com/SeaHub/BlogOfComputerNetwork/blob/master/res/con.png)
##### 分发链路状态包
还记得上面我们的描述么，将数据包发送给所有的其他的路由器，怎么发送到所有的路由器的，还记得我们之前提到过的泛洪算法么，现在就是它的用武之地了，用来发送数据包给所有的路由器
。不过在分发数据包的过程，我们还有一些问题要解决一下:
* 发送的数据包包括了序号，如果序号绕回，就可能产生混淆了，所以使用32位的序号是一个较好的解决方法，因为即使是一秒发送一个数据包，也要137年才能绕回
* 如果一个路由器崩溃了，那么保存的序号记录就会全部丢失，如果再从0开始，那么下一个数据包将被作为重复数据包被拒绝，那么应该怎么办呢
还记得上面提到的那个年龄的字段么，它就是用来解决这些问题的，每个数据包包含一个年龄的字段，然后每秒钟将年龄减1.当年龄值减为0时，就丢弃该数据包。所以这在泛洪算法中，
数据包就不会永远生存下去了
这个算法的改进使算法更加健壮了。当一个链路状态数据被泛洪到一个路由器时，它没有立即被排入队列等待运输，相反，它首先被放到一个保留区中等待一段时间。如果在这个数据包转发出去之前有新的数据包到来
，那么就比较他们的序号。序号相等的话，就丢掉一个重复的数据包，如果不等的话，就丢掉老的数据包。为了防止线路产生错误导致丢包和错包，所有的链路状态数据包都要被确认
### 结语
链路状态算法相比矢量路由算法，它因为没有无穷计数产生的慢收敛问题，所以工作得更好，但是因为它的缓冲区等要求，就需要更多的内存和计算。
作了简单的了解之后，我们下次再去其他有关路由算法的东西。因为网络层一大核心就是路由算法，所以我们还是要多多关注

