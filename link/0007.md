# 浅谈数据链路层02
阅读难度 低

记得上个星期我们谈论了链路层的一些基本内容，我们今天就来谈论一下纠错码和检错码
### 纠错码
* 海明码
* 二进制卷积码
* 罗德所罗门码
* 低密度校验码

为了实现纠错的功能，我们都要在待发送的信息里面添加冗余信息。一帧通常由m个数据位（有效数据）
和r个冗余位（校验）组成。根据数据位和校验位不同的组成方式，又可以把纠错编码分为以下几种
* 块码 ：r个校验位是作为与之相关m个数据位的函数计算出来的，就像在一张大表中找到m位数据位对应的
r位校验位那样
* 系统码： 直接发送m个数据位,然后发送r个校验位，它们之间没有编码关系
* 线性码： r个校验位是作为m个数据位的线性函数计算出来的
 
根据纠错码的使用广泛程度，我们还是谈谈使用得最广泛的卷积码和罗德所罗门码
#### 卷积码
在卷积码中，编码器处理一个输入位序列，并生成一个输出位序列，输出取决与当前的输入和以前的输入，所以
决定当前输出的以前输入位数称为代码的约束长度

![](https://github.com/SeaHub/BlogOfComputerNetwork/blob/master/res/correct_code1.png)
如果输入序列为111，输入序列会进入编码器的寄存器(register,简称reg),每一个寄存器都会储存一个输入单元
，而它们的初始值都是0。如图，编码器有3个模2加法器（相当于异或门），运算后，寄存器的
值会后移一格，然后继续将信息传至输出端，这样就可以得到想要的传输的内容了
output1=reg.1+reg.3
output2=reg.1+reg.2+reg.3
因为数据是依据输入到编码器的，所以3个寄存器的储存信息分别是：reg1是目前输入数据，reg2是上次
输入的数据，reg3是上上次输入的数据。
卷积码的解码过程是针对一个输入序列，找出最有可能产生的输出位序列(包括任何错误)，对于较小的约束长度
k，用Viterbi开发的算法逐个检查观察到的序列，记住每一步的和输入序列的每个可能内部状态，即输入序列
产生观察序列可能产生的错误，最终其中那个具有最少错误的输入序列就是最有可能的消息。
#### 里得所罗门码
里德所罗门码基于这样的一个事实的，每个n次多项式是由n+1点确定的。例如，一条具有ax+b形式的线
是由2个点所决定。同一条线上的其他点都是冗余的，这个就有助于我们纠错了，
可以想象有两个数据点代表一条线，并且我们给这两个数据点额外加上两个校验点，该两个校验点选自同一条线
，如果收到的其中一个点出现错误，我们仍然可以通过接收点的拟合点来回复这个数据点
。三个点将处在同一条直线上，而出错的那个点不在这条线上，只要找到这个点，我们就能纠正错误了
这个就是里德所罗门码的基本实现原理

### 检错码
我们上个星期说到过，纠错码被用于错误率较高的无线链路，那么检错码是用于错误率较低的光纤等可靠链路
，偶尔出错，通知发送方重传就行了
有这几种常用的检错码
* 奇偶
* 校验和
* 循环冗余校验

我们打算来介绍在链路层使用最广泛的检错码，循环冗余校验码（CRC,Cyclic Redundancy Check）
CRC码是由两个部分组成，前部分是信息码，就是需要校验的信息，后部分就是校验码
如果CRC码共长n个字节，信息码长k个字节，就称为(n,k)码，它的编码规则是：
###### 移位
将原信息码(k字节)左移r位(k+r=n),运用一个生成多项式g(x)也可以看成二进制数，有模2除上面的式子
得到的余数就是校验码，模2除的真值和模2加一样，就是我们可以理解成异或计算

生成多项式应满足的原则
* 生成多项式的最高位和最低位必须是1
* 当被传送信息(CRC)r任何一位发生错误时，被生成多项式做模2除后应该余数不为0
* 不同位发生错误时，应该使余数循环
* 对余数继续做模2除，应使余数循环


在实际应用中,多项式g(x)的取值是有限制的，有以下的国际标准
* CRC-CCITT=x^16+x^12+x^5+1*
* CRC-16=x^16+x^15+x^2+1
* CRC-12=x^12+x^11+x^3+x^2+x+1
标准还有其他，我就不一一列出来了
我们觉个例子来说明CRC码吧
###### 例子
例如：g(x)=x^4+x^3+x^2+1，（7,3）码，信息码110产生的CRC码就是
11101 | 110,0000（设a=11101 ，b=1100000）
对于g(x)=x^4+x^3+x^2+1的解释：（都是从右往左数）x4就是第五位是1，因为没有x1所以第2位就是0
用b除以a做模2运算得到余数：1001
余数是1001，所以CRC码是1001，传输码为：110,1001
