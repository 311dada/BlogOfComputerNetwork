# 浅谈数据链路层06之多路复用协议
* 阅读难度 中
#### 前言
之前我们提到了多路复用协议，并且举出了第一个协议 纯ALOHA,不过这个协议有诸多性能问题，所以现在我们
一起来了解一起其他的多路访问协议
### 分槽ALOHA
鉴于纯ALOHA令人抓狂的性能问题，研究人员就推出了一种ALOHA的改进版--分槽ALOHA，顾名思义，分槽就是将
时间分成离散的间隔，这种时间间隔就被称作时间槽，然后每个时间槽对应一帧。这种方法要求用户遵守同一的
时间槽边界。取得同步时间的一种方法就是由一个特殊的站在每个时间间隔发起一个脉冲信号，就好像时钟
整点报时那样

与纯ALOHA不同的是，在分槽ALOHA中，站不允许用户每次敲入回车键就发送帧，相反，它必须等到下一个时间槽的开始
时刻，这样，连续的纯ALOHA就变成了离散的ALOHA,这样可以把冲突减少一半
![](https://github.com/SeaHub/BlogOfComputerNetwork/blob/master/res/compare.png)

如图，并且想象现在可能的冲突。在测试帧所在的同一个时间槽中没有其他流量的概率是e^-G(e的负G次方)，G是
发送每个包是的尝试次数，于是可以得到 *S=Ge^-G* 分槽ALOHA的尖峰在G=1处，此时吞吐量是S=1/e，大约是
0.368，是纯ALOHA的两倍，但是我们也可以看到随着每次发送包时尝试次数的增多，信道性能也随之降低

### 载波监听多路协议
虽然分槽ALOHA是纯ALOHA性能的两倍，但是它可以达到的最佳利用率也只有1/e。这结果真的很难令人满意。
所以，我们需要一些更优秀的协议。
ALOHA性能不佳的很大原因是因为冲突，如果我们可以想办法避免冲突的话，效率会不会提高上去，答案当然是
肯定的。那么，如何避免冲突呢，考虑一下，如果别的站在发送信息，我们就先不发送，等到没有站发送的时候
再去发送，不就可以大大降低冲突的机率了么？这种通过站监听是否存在载波(即是否有传输)，而采取相应的
行动的协议就被称为载波侦听协议
#### 1-坚持载波检测多路访问(CSMA)
这是我们了解的第一个载波侦听协议,也是最简单的CSMA方案。具体协议是当一个站要发送内容的时候，首先会
侦听信道，如果信道空闲，那就发送，如果信道忙，那就等待，一直等待空闲，然后再发送。如果发生冲突
那就等待一段随机时间。再重复上面的动作。似乎协议很优秀，但是我们来假设一些情况，加入有三个站，
第三个站在发送，然后第一第二个站准备发送，但是它们同时侦听到信道忙碌，它们就很礼貌地等待起来。等
第三个站已发送完，因为不知道还有其他的站在侦听准备发送，他们就同时开始发送信息，就造成冲突了。还有
一种更微妙的情况，假如站B已经发送了信息，但是信息在信道有一定的延迟，还没到达站A，恰好站A准备发送
信息，就侦听信道，因为站B的信息还没到，所以显示是空闲，A就准备发送了，但是这个时候站B的信息刚好到了
站A又发送信息了，就会出现冲突了。
#### 非坚持CSMA
在这个协议中，站在发送数据前，也会对信道进行监听，如果空闲的话，就会发送数据，如果信道正在使用的话
，它就不会继续监听，它会"走开，去散散步(等待一段随机的时间)"，然后在重复上面的算法。与第一种CSMA
协议不同之处在于，它不会在信道使用的时候也一直监听着，以便信道空闲就发送数据。所以这就是为什么叫做
非坚持CSMA的原因了。相比之下，它更加"谦让有礼"
#### p-坚持CSMA.
当一个站要准备发送数据时，它就侦听信道。如果信道是空闲的话，它就按照概率P发送数据;而以概率Q=1-P
，将此次发送推迟到下一个时间槽。如果下一个时间槽信道也是空闲，它就按照概率P发送数据，或者按照概率Q
再次发送数据。这个过程会一直重复，直到帧被发送出去，如果帧还没有发送出去，另外一个站开始发送数据
，这个站就好像冲突发生那样，等待一段随机时间，然后继续重复上面的算法.概率P是一个给定值
#### 总结
现在我们就来看一下不同协议的 可计算吞吐量和负载之间的关系(坚持CSMA前面的数值是信道空闲时发送的概率)
![](https://github.com/SeaHub/BlogOfComputerNetwork/blob/master/res/summary.png)
